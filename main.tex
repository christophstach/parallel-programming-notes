\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{float}

\newcommand{\eqname}[1]{\tag*{#1}}% Tag equation with name


\title{Parallel Programming Overview}
\author{Christoph Stach}
\date{January 2020}

\begin{document}

\section{OpenMP}

\begin{listing}[H]
\begin{minted}{cpp}
#include <omp.h>

omp_get_num_procs(); // Total number of threads available
omp_get_thread_num(); // Current Thread
omp_get_num_threads(); // Number of open threads

#pragma omp parallel
#pragma omp parallel num_threads(threadCount)

#pragma omp parallel
{
  #pragma omp sections
  {
    #pragma omp section
       structured_block_1
           ...
    #pragma omp section
       structured_block_2
           ...
  }
}

#pragma omp prallel for
for(...) { ... }

#shared // shared between all threads
#private // copy of the variable without initialization
#firstprivate // gets copy of data before parallel region
#lastprivate // transfers back to non parallel region

#pragma omp critical // für kritische regionen mit shared variablen

#pragma omp parallel for private(val) reduction(+:sum)
for (row = 0; row < Rows; row++) {
  sum += val;
}
\end{minted}
\end{listing}

\noindent Variablen aus anderen Threads dürfen ohne shared nicht verändert werden.

\section{MPI: Message Passing Interface}


\begin{itemize}
    \item MPI ist ein Kommunikationsprotokoll für die Programmierung von Parallelrechnern.
    \item Sowohl Punkt-zu-Punkt- als auch Kollektivkommunikation werden unterstützt.
    \item vor allem für distributed-memory system
    \item ist auch für shared-memory system geeignet
\end{itemize}

\begin{listing}[H]
\begin{minted}[breaklines]{cpp}
#include <mpi.h>

int main(int argc, char **argv) {
    int commSize; // number of processes
    int myRank; // current process rank (ID)

    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &commSize);
    MPI_Comm_rank(MPI_COMM_WORLD, &myRank)
    
    if(myRank != 0) {
        // child processes send data
        // MPI_Probe auf status (tag) testen
        // tag: MPI_FLOAT, MPI_INT, MPI_CHAR
        
        MPI_Send(buffer, count, type, dest, tag, comm); // Point-to-Point blocking
        MPI_ISend(buffer, count, type, dest, tag, comm, request); // Point-to-Point none-blocking
    } else {
        // root process receives data
        for(...commSize) {
            MPI_Recv(buffer, count, type, source, tag, comm, status); // Point-to-Point blocking
            MPI_IRecv(buffer, count, type, source, tag, comm, request); // Point-to-Point none-blocking
        }
    }
    
    
    MPI_Bcast(...); // Broadcasting to all processes
    MPI_Barrier(...) // Wait for all processes
    
    MPI_Scatter(void* send_data, int send_count, MPI_Datatype send_datatype, void* recv_data, int recv_count, MPI_Datatype recv_datatype, int root, MPI_Comm communicator); // rsendcount sollte reicvcount sein
    MPI_Gather(void* send_data, int send_count, MPI_Datatype send_datatype, void* recv_data, int recv_count, MPI_Datatype recv_datatype, int root, MPI_Comm communicator);
    
    
    MPI_Reduce(...);
    
    MPI_Finalize();
    
    return 0;
}

Achtung mit MPI_Send und MPI_Recv wegen Deadlocks.


\end{minted}
\end{listing}

\section{Cuda}

\section{OpenCL}

\section{Hadoop}

\section{Spark}

\section{NP-Probleme}

\section{Beweisverfahren}

\subsection{Vollständige Induktion}


\subsubsection{Aufgabe 1}

\noindent Zuerst die Aufgabenstellung niederschreiben
\begin{align*}
    \sum_{k=1}^{n}k = \frac{(n + 1) * n}{2}
\end{align*}


\noindent \textbf{Induktionsanfang:} Beweisen das Aussage für $ n  = 1 $ wahr 
\begin{align*}
    \sum_{k=1}^{1}k = 1
\end{align*}

\noindent Rechte Seite ausrechnen:
\begin{align*}
    \frac{(1 + 1) * 1}{2} = 1
\end{align*}


\noindent \textbf{Induktionsbehauptung:} Behaupten das Aussage für $ n = n + 1 $
\begin{align*}
    \sum_{k=1}^{n + 1}k = \frac{((n + 1) + 1) * (n + 1)}{2}
\end{align*}

\noindent \textbf{Induktionschritt:}

\begin{align*}
    \sum_{k=1}^{n + 1}k  = \sum_{k=1}^{n}k + (n + 1) = \frac{(n + 1) * n}{2} +  (n + 1) = \frac{(n + 1) * n + 2(n + 1)}{2} = \frac{n^2 + n + 2n + 2}{2} = \frac{n^2 + 3n + 2}{2}
\end{align*}
\hrule
\begin{align*}
    \frac{((n + 1) + 1) * (n + 1)}{2} = \frac{(n + 2) * (n + 1)}{2} = \frac{n^2 + n +2n + 2}{2} = \frac{n^2 + 3n + 2}{2}
\end{align*}

\subsubsection{Aufgabe 2}


\noindent Zuerst die Aufgabenstellung niederschreiben
\begin{align*}
    \sum_{k=1}^{n} (2k - 1)^{2}  = \frac{n(2n - 1)(2n + 1)}{3}
\end{align*}

\noindent \textbf{Induktionsanfang:} Beweisen das Aussage für $ n  = 1 $ wahr ist:
\begin{align*}
    \sum_{k=1}^{n} (2k - 1)^{2}  = \sum_{k=1}^{1} (2k - 1)^{2} =  (2 * 1 - 1)^{2} =  1
\end{align*}

\noindent Rechte Seite ausrechnen:
\begin{align*}
    \frac{n(2n - 1)(2n + 1)}{3} =     \frac{1 * (2 * 1 - 1)(2 * 1 + 1)}{3} = \frac{1 * 1 * 3}{3} = \frac{3}{3} =  1 
\end{align*}



\noindent \textbf{Induktionsbehauptung:} Behaupten das Aussage für $ n =  n + 1 $ wahr ist:
\begin{align*}
    \sum_{k=1}^{n + 1} (2k - 1)^{2}  = \frac{(n + 1)(2 (n + 1) - 1)(2(n + 1) + 1)}{3}
\end{align*}


\noindent \textbf{Induktionsschritt:}
\begin{align*}
    \sum_{k=1}^{n + 1} (2k - 1)^{2} =  \sum_{k=1}^{n} (2k - 1)^{2} + (2(n + 1) - 1)^{2} = \frac{n(2n - 1)(2n + 1)}{3} + (2 * (n + 1) - 1)^2 = \\
     \frac{n(2n - 1)(2n + 1)}{3} + \frac{3((2 * (n + 1) - 1)^2)}{3} = \frac{n(2n - 1)(2n + 1)+ 3((2 * (n + 1) - 1)^2)}{3} 
\end{align*}

\hrule

\begin{align*}
\end{align*}


\end{document}
